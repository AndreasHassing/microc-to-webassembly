\documentclass[a4paper]{article}

\usepackage[english]{babel}
\usepackage[utf8]{inputenc}
\usepackage[hidelinks]{hyperref}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{setspace}
\usepackage{pdfpages}
\usepackage{xspace} %Removes space after commands
\usepackage{fancyhdr}
\usepackage{lastpage}
\usepackage{verbatim}
\usepackage{url}

%%% BibTeX %%%
\usepackage{cite}
% JS function to get BibTeX entry from WebAssembly website
\begin{comment}
function BibTeX() {
	let subject = document.title.replace(/ - WebAssembly/, '').replace(' ', '-').toLowerCase();
    return `@misc{website:wasm-${subject},
	author = "The WebAssembly working group",
	title = {{${document.title}}},
	howpublished = "${document.URL}",
	note = {Online; accessed 13 May 2017},
}`;
}
\end{comment}

% source: https://tex.stackexchange.com/a/35044
\makeatletter
\newcommand\footnoteref[1]{\protected@xdef\@thefnmark{\ref{#1}}\@footnotemark}
\makeatother

\makeatletter
\renewcommand\listoffigures{%
        \@starttoc{lof}%
}
\makeatother

% Code highlighting
\usepackage{minted}
% Highlight theme
\usemintedstyle{trac}

\pagestyle{fancy}
\fancyhf{}

\lfoot{Page \thepage \hspace{1pt} of \pageref{LastPage}}

\usepackage[margin=0.8in]{geometry}

\title{Bachelor Project Report: Compiling MicroC to WebAssembly}

\begin{document}
\includepdf[pages={1}]{ITUFrontpage.png}
%\pagenumbering{gobble} %Remove page numbers
\begin{titlepage}
	\centering
	{\scshape\LARGE IT University of Copenhagen \par}
	\vspace{1cm}
	{\scshape\Large Bachelor Project Report\par}
	\vspace{1.5cm}
	{\huge\bfseries Compiling MicroC to WebAssembly \par}
	\vspace{2cm}
	{\includegraphics{WebAssemblyLogo} \par}
	\vspace{2cm}
	{\Large\itshape Andreas Bj√∏rn Hassing Nielsen\par}
	abhn@itu.dk\\
	\vspace{2cm}
	{\Large Abstract\par}
	{\bfseries This report scrutinises the new executable format for the web: WebAssembly. To assist in this venture, a compiler is written from a simple C-like language called MicroC. Although writing and designing compilers is a complex task, there are tools like FsLexYacc, a Lexer and Parser generator for F\#, that can alleviate the process - such tools, and more, are used in this project to great effect.}
	\vfill
% Bottom of the page
	{\large \today\par}
\end{titlepage}
\newpage

\tableofcontents

\newpage
\section{Introduction}
\label{sec:introduction}
The purpose of this project is to build a compiler, also called a translator, from MicroC to WebAssembly, using FsLexYacc\footnote{\label{footnote:fslexyacc-url}http://fsprojects.github.io/FsLexYacc/} and F\#\footnote{http://fsharp.org/}. The learning goals are to develop an understanding of WebAssembly, and to improve my knowledge of compiler design.

MicroC is a C-like language described by Peter Sestoft in the book Programming Language Concepts~\cite{PLC}. The original lexer and parser code can be found at his website\footnote{http://www.itu.dk/people/sestoft/plc/}.\\

This report will give a in-depth explanation of how the WebAssembly format works and discuss how a compiler, that goes from a C-like language to this new format, can be designed.\\

I have previously had experience with compiler design. In the course: "Programs as Data", I extended the MicroC compiler with a handful of features: optimisations in the backwards continuation-based MicroC compiler, more looping constructs, compound assignment operators, increment/decrement operators and more.

While these feature additions don't teach compiler design from-scratch, I elected to do this project because I was confident that observing and analysing the behaviour of the original compiler yielded enough knowledge to get started writing my own.

MicroWac, the name of the MicroC to WebAssembly compiler described in this report, uses the abstract syntax (with some extensions) and the lexer and parser from the original MicroC project by Peter Sestoft. The compiler is written from scratch, as the differences between the MicroC stack machine and WebAssembly binaries are significant.

\section{Background and Problem Definition}
\label{sec:problem-definition}
WebAssembly (WASM) is a new up-and-coming binary code format for the user-facing web, designed to work alongside JavaScript as a more portable, size- and load-time-efficient, ahead-of-time-compiled alternative. 

The binary WASM format is not bound to be emitted by JavaScript (asm.js) only, potentially bringing your favourite language to the browser front-end. If a language can compile to a intermediate representation supported by WASM (LLVM IR, for instance), it can be compiled to the binary WASM format. 

The purpose of this project is to shed some light on the unfinished WebAssembly specification. To assist in meeting this goal, a compiler will be designed, that compiles from a simple programming language, MicroC, to a WASM format that can be run in a WASM-enabled browser today (currently requiring Firefox Nightly or Chrome Canary with WASM flags set to enabled\footnote{At the time of writing (May, 2017), setting flags or using a nightly browser version is no longer required. Major browsers now support WASM out of the box: https://lists.w3.org/Archives/Public/public-webassembly/2017Feb/0002.html}).

\subsection{Method}
\label{sec:problem-definition:method}
What follows are the planned activities and sources of information.
\begin{itemize}
	\item Translation of MicroC to the binary WebAssembly format, using FsLexYacc\footnoteref{footnote:fslexyacc-url}, as used in the Programs as Data course (fall 2016).
	\item Course books from Programs as Data (fall 2016) will be used as knowledge base for MicroC to WebAssembly translation:
		\begin{itemize}
			\item Peter Sestoft: Programming Language Concepts. Springer 2012.
			\item Torben Mogensen: Basics of Compiler Design. DIKU 2010. Chapters 2 and 3.
		\end{itemize}
	\item Knowledge of WebAssembly will be gained through the official website (http://webassembly.org/) and links branching out from it.
	\item Creation of prototype: web interface that lets users type MicroC in a window, and see it generate WebAssembly in some human-readable format, either s-expression or linear bytecode. The prototype will also give users the ability to run their code as WebAssembly, given that the browser in use supports it.
	\item Reflection over, either the security behind WebAssembly or the portability of it between browsers and platforms.
\end{itemize}

\noindent If time allows:
\begin{itemize}
	\item Extensions to the MicroC language will be implemented.
	\item Simple optimizations to the generated WebAssembly code.
\end{itemize}

\subsection{Changes to Method and Problem Definition}
\label{sec:problem-definition:changes}
I realised while coding the compiler, that I would have to stop working on it prematurely to get the web back- and frontend working as well. This was an underestimation on my part.

In a meeting with Niels Hallenberg on May 1st we agreed to discard the web part of this project. In an attempt to make up for the loss, I have added a flag (\texttt{-html}) to the compiler which generates a HTML template to go along with the \texttt{.wasm} output. The HTML template makes it easy to test compiled WebAssembly binaries, as you can serve the HTML with a simple HTTP server, see section~\ref{sec:peripherals:testing-wasm},~\nameref{sec:peripherals:testing-wasm}, on how to do that.\\

\noindent I do not feel that I have the knowledge required to reflect over the security of WebAssembly. Discussing the portability of WebAssembly also feels a little out of my reach - I can make assumptions about, how I fear that later versions of WebAssembly will diverge, in the case that a browser vendor feel that development of the standard is too slow, but in the end I do not feel that this is a very important discussion to have in this report. Instead I have spent some time extending MicroC with \texttt{import} and \texttt{export} keywords, and discuss the implementation of these in section~\ref{sec:technical},~\nameref{sec:technical}.\\

\noindent As of Chrome version 57 and Firefox version 52\footnote{https://developer.mozilla.org/en-US/docs/WebAssembly\#Browser\_compatibility} it is no longer required to set flags in browsers, or use nightly browser versions in order to run WebAssembly binaries.

\newpage
\section{Problem Analysis}
\label{sec:problem-analysis}
In this section, the problem will be dissected and analysed. The definition of a compiler and a stack machine is discussed, and the WebAssembly specification and binary encoding is scrutinised. Some history is also supplied, to help explain the purpose and origin of WebAssembly.

\subsection{Compilers in General}
\label{sec:problem-analysis:compilers}
Before designing a compiler, an important question must be put forth and answered: "What is a compiler?".

According to the definition laid out by Mogensen~\cite{BCD}, a compiler is a program that takes the source code of another program as input, usually some higher-level language such as C\#, and compiles it to a lower-level representation, Common Intermediate Language code - in the case of C\#, or binary machine code instructions - in the case of C. There are more low-level representations out in the wild, but these two will be the ones referenced to in this report.

Compilers are separated into a frontend and a backend. The frontend is responsible for parsing the code written by a developer and turning it into an abstract syntax. The backend converts the abstract syntax into a format the targeted system can understand. In MicroC, the lexer and parser that is defined in \texttt{CLex.fsl} and \texttt{CPar.fsy} respectively, make up the frontend part of the compiler, whereas \texttt{WasmMachine.fs} and \texttt{Wasmcomp.fs} make up the backend part. The frontend and backend work in tandem to take user-written code as input, and output a program that the machine can run. In the case of this project: a program that a WebAssembly machine can run.

The decoupling of the frontend and backend in a compiler yields a great benefit: A new frontend can be added for a backend, thus supporting more languages that compile to the same type of backend, and a new backend can be added to a frontend, such that the compiler supports more systems. If, for instance, we wrote a compiler that compiles from F\# to WebAssembly, we could add an extra frontend that parses C\# and reuse the backend. This separation is used in the LLVM compiler, which supports many backends and frontends, and defining a target-independent intermediate representation which can be used across languages and systems\footnote{http://llvm.org/}.\\

Many programs are written in higher-level languages that run within an assisting runtime environment and compiles to a variant of bytecode, with an instruction set specified in the virtual machine of the runtime. When the runtime is started and the program bytecode is passed to it, it performs a just-in-time (JIT) compilation to native machine code using the instruction set of the machine's processor. .NETs' CLR and Javas' JRE are two such runtimes that both support several higher-level languages, such as C\#, F\#, Java and Scala. Runtime environments often come equipped with integrated memory management in the form of a garbage collector.

Programs written in comparatively lower-level languages, such as C and C++, are usually compiled ahead-of-time (AOT) to native machine code using the instruction set of the compiling machine. One can often configure the compiler to target other operating systems and processor architectures than that of the compiling system. In these lower-level languages, the developer is often challenged with manually managing dynamic memory. In C, this means using \texttt{malloc} and \texttt{free} for allocation and deallocation of memory while the program is running.

Note, that nothing stops us from implementing a runtime environment that supports a language which is usually AOT compiled, such as C. Such a runtime environment can then execute code written in that language as a JIT compiled application. With C, this task is most likely non-trivial.\\

The notion of forward and backward compilation will be mentioned in this report, it describes the direction of compilation. Peter Sestoft has designed a forward compiler for MicroC (\texttt{Comp.fs}) and a backward continuation based compiler (\texttt{Contcomp.fs}). The purpose of the backward continuation compiler is to display how some easy optimisations can be implemented when compiling in that particular direction. MicroWac will be a forward compiler with no optimisations.

\subsubsection{Linking}
\label{sec:problem-analysis:compilers:linking}
When compiling, a program usually has some sort of dependencies. For C, it could be the standard library, and an IO function in that library. Dependencies can be linked either at compile time, or at runtime.

Linking at compile time is called "static linking". Static linking combines the program with its dependencies into a single binary file.

Runtime linking, also known as "dynamic linking", is used by WebAssembly. Dynamic linking allows dependencies to be linked at runtime. A large benefit of this model is: as long as there are no breaking changes to a dependency, it can be updated without recompiling the dependent program, the binary of the dependency can be replaced with an updated version. The .NET platform also uses dynamic linking, usually by linking against \texttt{.DLL}-files (Dynamic-link library).

\subsubsection{Benefits of AOT- over JIT Compilation}
\label{sec:problem-analysis:compilers:benefits-of-aot}
\textbf{Type Safety} When a statically typed language is compiled ahead-of-time, the compiler can complain to the developer before the program even reaches a runtime environment. For instance, if the developer attempts to assign a char value to a variable that is declared to contain an integer, the compilation will fail. This is useful for producing correct code. JavaScript is a loosely typed language, meaning that type checking occurs at runtime, and type errors that the developer was not aware of during development may turn up as the program is executed in the browser.\\

\noindent \textbf{Optimisations} While optimisations can be made by both an AOT and JIT compiler, an AOT has all the time a developer has to spare to optimise. A JIT will need to weigh the potential gain of an optimisation against slowing down the program during the consideration process~\cite{website:mozhack:fast-wasm}. This makes an AOT compiled language preferred for live and runtime critical systems as the execution path is deterministic.

\subsection{Stack Machines}
\label{sec:problem-analysis:stack-machines}
Stack machines implement some derived behaviour of what is known as the abstract stack machine. The stack machine executes code by pushing values onto- and popping values off a stack data structure, hence the name. The instructions are added to the stack using reverse polish notation, also called postfix notation. This notation works by computing in postfix, rather than infix, for instance: \mintinline{fsharp}{3 + 4} becomes \mintinline{fsharp}{3 4 +}. The machine keeps popping the top element on the stack to figure out what to do next.

Specific implementations of stack machines have a set of instruction codes that can be used. For instance, the WebAssembly stack machine has the \texttt{i32.add} instruction code, which, when popped, pops two operand values off the stack, adds them together and pushes the result back onto the stack. Several arithmetic-, logic- and other instruction codes are available in the WebAssembly stack machine~\cite{website:wasm-binary-encoding}.

Most computers aren't pure stack machines, but some derived combination of a stack machine, a register machine (which uses registers to store operands and intermediate values) and other machine types. As such, a stack machine can be thought of as an abstraction on top of the machine architecture.

Assembly language (not WebAssembly) is the closest, somewhat sane, code representation that exists to code directly against the central processing unit. This language uses reverse polish notation, just like a stack machine, and utilises registers that are closer to the central processing unit than random access memory. When a browser compiles WebAssembly (which does not use registers), registers are used, and disassembling the LLVM output of a WebAssembly compilation done by browsers\footnote{The tool that enables this level of inspection: https://mbebenita.github.io/WasmExplorer/} proves this\footnote{WasmExplorer used to compile a simple C program to WebAssembly, then to LLVM x86 Assembly: https://goo.gl/nUqTZ1}.

A specific version of the Assembly language exists for each instruction set architecture, but they usually have several similarities. An Assembly language exists which attempt to support several platforms\footnote{NASM (The Netwide Assembler) is an assembly language that is designed for portability, and can be compiled for execution on multiple operating systems and processor architectures (x86/x86-64): http://www.nasm.us/}.

\newpage
\subsection{History of Web Coding}
\label{sec:problem-analysis:history}
Less than a year ago there was only 1 language that could run natively in all browsers: JavaScript. The web is built around it, and the language has flourished and expanded beyond the land of browsers, in the form of execution environments such as Node.js\footnote{https://nodejs.org/} and native application frameworks such as React Native\footnote{https://facebook.github.io/react-native/} and Electron\footnote{https://electron.atom.io/}.

Attempts have been made to make JavaScript run faster, but ultimately no new standards have been made other than WebAssembly. One of the more popular attempts is asm.js\footnote{http://asmjs.org/spec/latest/}. asm.js is a subset of JavaScript, with tooling that allows for source-to-source compilation from languages such as C and C++ to asm.js. The subset allows static type checking by browsers that implement a specific parser for asm.js. Drafted in 2014 - asm.js yielded good results\footnote{http://asmjs.org/faq.html}, but work on the format seems to have shifted to WebAssembly, due to the large size of compiled code bases (non-binary). The binary WebAssembly format is much smaller, and can be compressed even more than the code yielded by asm.js, furthermore parsing of binary data is significantly faster than that of strings, thus decreasing the time-to-execution of compiled WebAssembly modules versus asm.js code.

\subsubsection{JavaScript}
JavaScript is a loosely typed language that runs in browsers. JavaScript code written by a software developer needs to be sent via a website, to the visitors browser, the code will execute immediately on arrival.

JavaScript is compiled by a JIT compiler at runtime\footnote{This is not always true. Ignition, a newly developed interpreter for V8 (Chrome's JavaScript engine), is used alone or along with JIT compilation, especially on devices where a lower- memory footprint, or battery usage is preferred over high performance (Smartphones, for instance)~\cite{video:thompson-js-perf-v8-and-wasm}.}, which takes the code, converts it into abstract syntax and then to machine code~\cite[p.~13]{slides:lund-v8}. During the execution of a JavaScript program, the JIT compiler will attempt to optimise the generated machine code by making probabilistic assumptions about program behaviour. These assumptions can eventually fail, thus forcing the JIT to throw away optimisations based on falsified claims - this is a cause of non-deterministic execution speed of JavaScript programs. The JIT's that are found in modern browsers make a lot of intelligent optimisations on what is generally referred to as \texttt{warm} and \texttt{hot} code paths\footnote{Warm and hot code describes code paths that are executed regularly and often, respectively.}, thereby greatly increasing performance without sacrificing excessive resources. When a JIT compiler is run on a system with multiple processor cores, it can run in parallel, thereby generating optimisations without blocking the main thread of the browser.

\subsection{WebAssembly}
\label{sec:problem-analysis:webassembly}
WebAssembly can be expressed using two formats: a binary syntax (.wasm files) that can be executed in browsers (and Node.js behind a flag: \texttt{--expose-wasm}), and a textual representation (.wast files) called the S-expression syntax (WAST).

The binary syntax contains a magic number which states that the module is WebAssembly and the version number of the binary. Then follows a number of sections that describe the intricacies of the module. The binary module is described in more detail in section~\ref{sec:problem-analysis:webassembly:binary},~\nameref{sec:problem-analysis:webassembly:binary}.

Binary files are not readable to the human eye, so S-expressions is also available. The S-expression syntax for WebAssembly was described in order to keep the "View Source" functionality of the Web\footnote{You can view the source code of any JavaScript code running in your browser by right-clicking a website. The WebAssembly working group wishes to keep this tradition with WebAssembly~\cite{website:wasm-webassembly-high-level-goals}.}.

The WebAssembly Working group has developed WABT\footnote{https://github.com/WebAssembly/wabt/}, a toolkit that allows bidirectional translation between the binary syntax and the S-expression syntax. The toolkit, and how to use it, is described in detail in section~\ref{sec:peripherals:wabt},~\nameref{sec:peripherals:wabt}. Browsers could use this toolkit, or a functionally equivalent derivative, to translate binaries to the S-expression syntax, such that viewing the source of WebAssembly binaries on arbitrary websites is easy.

WebAssembly is designed to work well together with JavaScript~\cite{website:wasm-webassembly-high-level-goals}. This can be deduced without looking at the goals of WebAssembly, by inspecting the design of the binary- and textual representation of WebAssembly. Code compiled to WASM is turned into modules that can be instantiated from JavaScript, and WebAssembly modules can selectively define which components to expose to- and import from JavaScript.

Exported and imported components from and to WASM can be of types: functions, variables and memory segments. This design allows WASM modules to make use of dependency injections, which can assist in decoupling code and separating implementation concerns. By using this design, WASM can dynamically link libraries and implementations.

\subsubsection{The S-expression Syntax}
\label{sec:problem-analysis:webassembly:s-exp}
The S-expression syntax is easily explained with an example:
\begin{minted}[tabsize=2]{javascript}
(module
  (func $printi (import "imports" "printi") (param i32))
  (func $start
    (local i32)
    i32.const 5
    i32.const 3
    i32.add
    set_local 0
    get_local 0
    call $printi
  )
  (start $start)
)
\end{minted}
The code above describes a module. Within that module are functions \texttt{printi} and \texttt{start}. The \texttt{printi} function is imported from an object named \texttt{imports} and a field within that object named \texttt{printi}, it takes a single 32-bit integer as parameter. The \texttt{start} function declares a local 32-bit integer variable. Note that local variables need to be declared at the top of a function, this behaviour is even more strict than the C89 specification, which allows variable declarations in the top of any block. The function then pushes constant 32-bit integers $5$ and $3$ onto the stack, and then a 32-bit addition operator. The local variable is set to the top value on the stack (the result of the addition) and \texttt{printi} is called, taking the top value on the stack as argument.

A \texttt{start} component dictates which function will run at instantiation-time. Functions must not take any arguments and must not return a value in order to be valid for \texttt{start}. This is in contrast to the typical \texttt{main} entry point function, which usually takes an argument count and a string array of arguments. MicroC uses the \texttt{main} version, so a compromise must be thought up to allow running MicroC programs at instantiation-time.

The \texttt{printi} function needs to be injected into the module from within the browser. This yields a freedom to the developer, offering the opportunity to easily change behaviour of WebAssembly modules. For instance, if a WebAssembly module imports some logging function, the developer can hand the module a very verbose logging function in the development environment, and a more quiet logging function in the released environment.

\subsubsection{The Binary Format}
\label{sec:problem-analysis:webassembly:binary}
The binary format of WebAssembly modules contains the magic number and several sections that determine the behaviour of the modules. Each section also contains the size of itself - this information can be used by a browser  to start working as soon as it receives the final byte of a section.

Number literals in the binary format are little-endian~\cite{website:wasm-binary-encoding}. When a number system is little-endian, the least significant byte of a number is stored at the lowest memory address.

The following sections~\cite{website:wasm-modules} in the binary format are relevant to MicroC (the number in this list corresponds to the ID of the section):
\begin{enumerate}
	\item Type section, keeps track of the set of unique function types in the program. For instance, if a function has a return type of void and takes an integer argument, that type information must be located in the type section. It is permitted to add more than one of the same type.
	\item Import section, keeps track of the imported functions and data from the environment. This is how WebAssembly handles dynamic linking.
	\item Function section, maps each function index to its type index (as found in the type section), information required by the WASM compiler in browsers to ensure the types of compiled functions are satisfied.
	\setcounter{enumi}{4}
	\item Memory section, keeps track of the amount of memory a WebAssembly modules has available at start, and (optionally) how much it is allowed to request in total. No information regarding what is inside the linear memory is contained in this section.
	\item Global section, keeps track of the global variables, their type and whether they can be mutated or not. This seems to be an obvious candidate for storing global variables, but is later revealed not to be the case.
	\item Export section, keeps track of exported functions, memory and global variables.
	\item Start section, contains a single value stating the ID of the function to start at instantiation-time.
	\setcounter{enumi}{9}
	\item Code section, the function code is stored here as stack machine instruction codes. Each function declaration in the code section is accompanied by a count of local variable declarations and information regarding what types they each have.
\end{enumerate}

Three sections are disregarded for this project: The table section, the element section and the data section. The table section is for indirect function calls on indexes - this was not useful to the MicroC compiler, as indirect calls is not a supported feature. The element section can be used to set the contents of a table - useless without the table section.

The data section can be used to initialise the data in linear memory at instantiation-time. A string can be put into linear memory via the data section, - but as strings are not supported in MicroC, it was redundant to include this section.

The S-expression syntax example from section~\ref{sec:problem-analysis:webassembly:s-exp},~\nameref{sec:problem-analysis:webassembly:s-exp}, has been compiled to binary format and explained in detail. This binary analysis can be found in~\ref{sec:appendix:wasm-examples:binary-print},~\nameref{sec:appendix:wasm-examples:binary-print}.

\subsubsection{Linear Memory}
\label{sec:problem-analysis:webassembly:linear-memory}
WebAssembly modules can declare the need for an array-like memory segment called the linear memory. The linear memory has its size defined by the number of pages, where a single page is 64KiB\footnote{64 Kibibytes $=$ 65,536 bytes.}. A WebAssembly module can have zero pages of memory, 1 page or $n$ pages, and can grow the memory at runtime if needed using the \texttt{grow\_memory} instruction code.

A developer can access data in linear memory by using a set of load- and store instruction codes. The codes that are interesting to this project can be found in the list below, they are selected based on what MicroC can compile to:
\begin{itemize}
	\item \texttt{i32.store}: Pops two elements element off of the stack, the first is the value that the memory location will be set to, the second is the location to set. This operation code can be used to set the values of variables where the address must be known (\texttt{\&x;} results in the address of \texttt{x}, thus it must be in referenceable memory). The operator must be accompanied by a \texttt{memory\_immediate}\cite[\#memory-related-operators]{website:wasm-binary-encoding} which describes the flags of the operator and the offset. The offset can be used to distinguish function scopes from each other, such that a variable declared inside a function is described by the functions memory offset plus the relative offset of the variable.
	\item \texttt{i32.load}: Pops an element off the stack and uses it as the address of a 32-bit integer to load from linear memory. Loads 4 bytes and puts the resulting integer onto the stack. This operation code can be used to load integer- and pointer values. Pointer values can be integers because the address space cannot be larger than 32-bits unsigned, as WebAssembly is 32-bit only~\cite[\#addressing]{website:wasm-semantics}.
	\item \texttt{i32.store8}: Similar to \texttt{i32.store}, but wraps the 32-bit integer to an 8-bit integer. This can be used for the MicroC char data-type which is a single byte (8 bits) wide.
	\item \texttt{i32.load8\_u}: Similar to \texttt{i32.load}, but only loads 8 bits and zero-extends to a 32-bit integer. This can be used to load a single byte from memory, i.e., a char.
\end{itemize}

\subsubsection{Aligning MicroC and WebAssembly}
\label{sec:problem-analysis:webassembly:aligning}
In this section, some discovered misalignments between MicroC and WebAssembly will be discussed and handled.

\noindent \textbf{The builtin print and println functions.} MicroC has two built-in functions: \texttt{print} and \texttt{println}. They are converted to internal \texttt{printi}, and \texttt{printc} functions, that print an integer and a char respectively. \texttt{println} is simply a call to \texttt{printc} with $10$ as an argument (10 is the new line feed character in ASCII\footnote{See http://www.asciitable.com/.}). A few ways on how this could be handled in the conversion to WebAssembly comes to mind:
\begin{itemize}
	\item The functions could be hardcoded as imports in the generated module, thus allowing the compiler to stay MicroC compliant, but forcing the user of the module to supply an implementation of the two functions.
	\item Remove the keywords and functionality from MicroC, and instead implement an \texttt{import} keyword in the compiler, such that function signatures can be specified which could then give the user more power over what kind of functions that must be imported. For instance, \mintinline{c}{import void print(int i);} would require the user of the module to hand an imports object to the module with a print function that takes an integer as argument and returns nothing. This design has a familiar resemblance to prototypes in C.

	A downside to this solution is that it breaks previously working MicroC programs that use the \texttt{print} or \texttt{println} functions.
\end{itemize}

\noindent \textbf{Stack Machine divergences.} The stack machine specified by Peter Sestoft for MicroC and the one specified for WebAssembly are quite different. What follows are some of the major contrasts.

Many instruction codes from the MicroC stack machine do not exist in WebAssembly (\texttt{ldi}, \texttt{sti}, \texttt{dup}, \texttt{swp}, and others). While the opposite is also true, to a great degree, missing instructions in the conversion from a MicroC stack machine to a WebAssembly one is the more problematic direction, as extra instructions in WebAssembly can be ignored.

The instruction code problem leads to the next issue: without \texttt{ldi}, how are variables loaded? It turns out, that WebAssembly does not have the modifiable and globally available stack, as in the MicroC stack machine. In the MicroC stack machine a base- and stack pointer is used to get access to variable adresses and values. In WebAssembly, there are 3 ways of storing and retrieving data: Global variables (using the instruction codes \texttt{set\_global} and \texttt{get\_global}), local variables (\texttt{set\_local} and \texttt{get\_local}) and data stored in linear memory (\texttt{i32.store} and \texttt{i32.load}). Normally, having three ways to do something is a good thing, but only data stored in linear memory can be accessed by address. This can generate some problems, as pointers and arrays are access-by-address.

In the following program, an integer is \texttt{x} is declared and its value set to $5$. Then the address of \texttt{x} is passed to the \texttt{changeInt} function along with the number $42$. At first glance, one could assume that creating a local variable in the \texttt{main} function and using \texttt{get/set\_local} would work, but it wont. Local variables have no addresses, and thus cannot be accessed by functions aside the one that declared it.
\begin{minted}[tabsize=2]{c}
void changeInt(int* i, int to) { *i = to; }
void main() { int x; x = 5; changeInt(&x, 42); }
\end{minted}

\noindent Possible solutions to this problem are:
\begin{itemize}
	\item Declare all variables defined inside a function block as locals, until they are referenced, at which point they are moved from the local environment to linear memory. Any access to the value of a variable inside linear memory variable will occur by dereferencing the address into the linear memory.
	\item A simpler version of the proposal above: declare all variables in linear memory, except for function arguments which are special.
\end{itemize}

Due to time constraints, I decided to go with the 2nd solution, but wanted to implement the 1st. See section~\ref{sec:technical:variables},~\nameref{sec:technical:variables}.

\newpage
\section{User Guide and Examples}
\label{sec:user-guide}

\subsection{Compiling the Compiler}
\label{sec:user-guide:compile-compiler}
To compile the compiler, some dependencies need to be resolved. To do this, use your terminal of choice, move to the root directory of the project, then resolve dependencies using \mintinline{bash}{nuget restore}\footnote{The path to the \texttt{nuget} command needs to be in the \texttt{PATH} environment variable. Can be downloaded from https://dist.nuget.org/index.html}.

After dependencies are resolved, ensure that the lexer and parser are up to date (they should be), by running the PowerShell script on Windows, found in \texttt{./micro-wac/pre-build-lexpar-comp.ps1}, or the bash script on a *nix OS, found in \texttt{./micro-wac/pre-build-lexpar-comp.sh}.

Once the lexer and parser are up to date, run \texttt{msbuild ./micro-wac/microwac.fsproj} on Windows (or compile via Visual Studio, a solution file is supplied), or \texttt{xbuild /target:micro-wac} on a *nix OS.

\subsection{Compiling a MicroC Program}
\label{sec:user-guide:compile-microc}
To compile a MicroC program, the compiler can be run with the following command:

\mintinline{bash}{microwac.exe [-v] [-html] <filename.c>}\\
on Windows, and

\mintinline{bash}{mono microwac.exe [-v] [-html] <filename.c>}\\
on OS X or Linux.\\

\noindent The flags are optional and have the following functionalities:
\begin{itemize}
	\item \textbf{-v}: Increase verbosity of the compiler. If the compiler fails it will print an error message, but with the verbose flag set it will also print a stack trace.
	\item \textbf{-html}: The HTML flag is implemented as a band-aid, in place of the web front- and backend. It outputs a HTML template to along with the binary \texttt{.wasm} output. You only need to expose the HTML document and WebAssembly module with a webserver hosting on localhost. See section~\ref{sec:peripherals:testing-wasm},~\nameref{sec:peripherals:testing-wasm}, for instructions on how and why.
\end{itemize}

\subsubsection{\texttt{hello\_number.c} Example}
The following program shows the syntax of printing numbers to an output channel in MicroC:
\begin{minted}[tabsize=2]{c}
void start() {
	print 42;
}
\end{minted}

When the program is compiled to WebAssembly, using MicroWac, the \texttt{print} function is supplied implicitly. As the function is named \texttt{start}, it will be run at instantiation-time. If the compiler is invoked with the \texttt{-html} flag, a template HTML file is also generated, which contains a simple output function that displays printed numbers on the screen.

\subsubsection{Example of import and export}
The following example shows how explicit imports and exports can be used from within MicroC. This feature is an extension to the MicroC language described in section~\ref{sec:technical:extension},~\nameref{sec:technical:extension}.

\begin{minted}[tabsize=2]{c}
// log_number is a function imported from JS
// the name implies that it logs a number somewhere.
import void log_number(int x);

// multiply_by_2 is an exported function that can
// be executed in the instantiating JS environment.
// The name is unambiguous.
export int multiply_by_2(int x) {
	return x * 2;
}
\end{minted}

This program requires some additional code in the HTML template in order to work. The module cannot be instantiated without being given a \texttt{log\_number} function. The HTML template, see section~\ref{sec:appendix:code:bootstrap-template},~\nameref{sec:appendix:code:bootstrap-template}, needs to have the \texttt{jsExports} object extended with (example implementation):
\begin{minted}[tabsize=2]{javascript}
let jsExports = {
	..., // snipped for brevity
	log_number: i => console.log(i)
}
\end{minted}

To call the exported \texttt{multiply\_by\_2} function, the following code can be added to the \texttt{.then}-statement in the HTML template:
\begin{minted}[tabsize=2]{javascript}
fetchAndInstantiate().then(module => {
	... // snipped for brevity
	let b = module.exports.multiply_by_2(42);
	console.log(b); // logs 84 to the console
});
\end{minted}
The code calls the function with 42 as an argument, stores the result in a variable \texttt{b} and then logs it to the console. Note, that exported functions can only be found in the \texttt{exports} property of the compiled module object, this is a WebAssembly JS API specification~\cite{website:wasm-javascript-api}.

\subsection{Additional Examples}
More examples can be found in \texttt{./micro-wac/test/} and in \texttt{./micro-wac/test/plc/} (made by Peter Sestoft).

In the folder \texttt{./micro-wac/test/expected-output/}, there are hand-written S-expression programs that resemble what the equivalent MicroC code was expected to compile to. Some of them are translations to examples in the test folder. A small test framework is written to expose the \texttt{wasm} samples to the browser, see section~\ref{sec:peripherals:run-test-framework},~\nameref{sec:peripherals:run-test-framework}, for more details.

\newpage
\section{Technical Description}
\label{sec:technical}
In this section, important design choices made during the project are discussed, and select technical aspects of the compiler is explained.

\subsection{MicroWac}
MicroWac is a forward compiler that depends on FsLexYacc to generate a lexer and parser by a supplied lexer spec, \texttt{CLex.fsl}, and parser grammar, \texttt{CPar.fsy}. It was decided to write the compiler in a forward style as it is a simpler model, and could later be rewritten to be backwards continuation style if a forward style was trivial to implement - this turned out not to be the case, so it remains a forward style compiler. Had the compiler been implemented using backward continuation style, optimisations from the course "Programs as Data" would've been easy to implement to the compiled code.

\subsubsection{Modules}
A dependency graph is supplied in section~\ref{sec:technical:dependency-graph},~\nameref{sec:technical:dependency-graph}, and it depicts how the modules in the MicroWac system depend on each other. What follows is a description of each of the files and their responsibilities:
\begin{itemize}
	\item \texttt{Absyn.fs}: Contains type information for the MicroWac abstract syntax tree. It is a slightly modified version of the one supplied by Peter Sestoft. Both the frontend and the backend parts of the compiler depend on this module.
	\item \texttt{CPar.fsy}: Contains the parser grammar which can be compiled with FsLexYacc into the signature- and implementation files: \texttt{CPar.fsi} and \texttt{CPar.fs}, respectively. Also used in lexer specification which needs it to know what kind of parser tokens to generate.
	\item \texttt{CLex.fsl}: Contains the lexer specification which can be compiled with FsLexYacc into the \texttt{CLex.fsi} and \texttt{CLex.fs}. The lexer tokenizes the MicroC code.
	\item \texttt{Parse.fs}: The parse code in this file uses the \texttt{CPar/CLex} modules along with a lexing module from the FsLexYacc runtime. It exposes two high-level functions that can be used to compile a MicroC program from a string (great for debugging in F\# interactive) and from file using a stream reader. Both functions output a \texttt{Program}, as specified in the abstract syntax.
	\item \texttt{WasmMachine.fs}: Handles type information for the construction of WebAssembly binaries. Also contains functions to convert the types to bytes, as bytes are needed to output binary WebAssembly modules.
	\item \texttt{Wasmcomp.fs}: The heart of the compiler backend. Has types that keeps structure over the function- and variable environments and memory management. The \texttt{cProgram} function takes a \texttt{Program} as input and returns the environments that are required for a program to be compiled to WebAssembly. The environments are generated using several folding functions. \texttt{compileWasmBinary} runs mapping functions on the output of the \texttt{cProgram} function in order to create a binary file containing the MicroC program translated to WebAssembly sections and code.
	\item \texttt{Program.fs}: Emits an entry point into the compiler and lets the compiler be run from a command line terminal. See section~\ref{sec:user-guide:compile-microc},~\nameref{sec:user-guide:compile-microc}, on how to use MicroWac from the terminal.
\end{itemize}

\subsection{Variable Management}
\label{sec:technical:variables}
Variables in the original MicroC stack machine are accessed via the stack pointer and base pointer. These two pointers are not available in WebAssembly, so a new way to handle variables is thought up in this section.\\

\noindent In early versions of MicroWac, variables were either local or global and could not be addressed. It was weighed beneficial to get the compiler to work early and then add features along the way. This initial version\footnote{https://github.com/AndreasHassing/microc-to-webassembly/blob/4d46e37ee1a5f9c39480a2fb375d59ced7152259/micro-wac/Wasmcomp.fs} turned out to need a lot of extension in order to work with addressable variables.

A variable environment is created to keep track of: variables declared globally and in separate functions, the next free argument ID, the next free relative address in the local scope, the current memory offset and the current depth of the environment. This environment can be passed forward in a fold, which will allow the environment data to be updated over the course of compilation. First, global variables are folded into an initial environment, then each function extends this environment separately.

As the local and global variable constructs in WebAssembly are unaddressable, see section~\ref{sec:problem-analysis:webassembly:aligning},~\nameref{sec:problem-analysis:webassembly:aligning}, it seems that, in order to address variables, putting them in linear memory is the only option. Data in linear memory can be accessed with an absolute address, or a relative address with an offset. This can be designed, such that each function starts with an offset of the next free address, and stores local variables relative to that offset.

\begin{figure}[H]
	\includegraphics[width=0.7\textwidth]{MemoryManagement}
	\centering
	\caption{Linear memory of a WebAssembly module. First at instantiation-time, then after allocating and assigning the value of a char, then after allocating and assigning the value of a 32-bit integer.}
	\label{fig:memory-management}
\end{figure}

Figure \ref{fig:memory-management} shows how global variables are allocated. The same algorithm is used to allocate local variables, except they are allocated in a per function scope, offset by the next free address at the time of compilation.

Linear memory resembles a heap, and is allocated as compressed as possible at compile time to avoid defragmentation.

A cleaner, and slightly more complex, solution to memory management could be to, only put: pointer variables, array variables, and variables whose address has been fetched with the ampersand operator: \texttt{\&var}, into linear memory. This way, unaddressed variables could be encoded as function-scoped WebAssembly local variables. A benefit of this could be, that functions using local variables can reap some benefits of variable locality, a feature that depends on the compiling browser. Unfortunately, I did not have time to implement this concept.

\newpage
\subsection{Compiling to WebAssembly}
\label{sec:technical:webassembly}
Some of the interesting intricacies of compiling to the WebAssembly binary format are dissected in this section.

\subsubsection{Instruction Opcodes}
Compared to MicroC, WebAssembly has a wide range of opcodes, including several control flow opcodes. This has allowed some very readable compiler code of, for instance, while loops and if-expressions.
An excerpt from the code found in \texttt{Wasmcomp.fs}:
\begin{minted}{fsharp}
| While (exp, stm) ->
  let loopVarEnv, loopCode = cStmt (deepen varEnv) funEnv stm
  shallow loopVarEnv, BLOCK (BVoid)
                      :: LOOP (BVoid)
                        :: cExpr loopVarEnv funEnv exp @ I32_EQZ :: BR_IF 1uy
                        :: loopCode
                        @  BR 0uy
                      :: [END;
                      END]
\end{minted}

The code compiles the loop code statement first. As statements can contain variable declarations, the variable environment must be deepened. Code generation is purposefully indented to look like an actual while loop construct in C.

The branching opcodes, also seen in the example above, do not branch to a specific label, instead they branch out of a relative depth. The \texttt{BR 0uy} opcode in the while loop breaks 0 depth out, meaning that it returns to the loop and executing the boolean expression and statement again. If the boolean expression equals zero, a 1 is pushed onto the stack which \texttt{BR\_IF} then consumes and uses to break 1 depth out to the surrounding block which then ends execution of the loop.

It has been important to inspect and study all the opcodes available in WebAssembly to ensure that MicroC is compiled as succinctly as possible.

The set of remaining instruction codes that are useful when compiling MicroC to WebAssembly are presented in \texttt{./micro-wac/WasmMachine.fsi}.

\subsection{Linear Memory}
\label{sec:technical:webassembly:memory}
In every module, MicroWac allocates a single page of memory (64KiB). This is the smallest amount that a WebAssembly module can demand. Linear memory is used to store global and local variables, such that they can be referenced by address.

The reasoning behind a single page of memory is, that it can store 16384 integers or 65536 chars\footnote{65536 bytes / 4 bytes per integer = 16384 integers. A char takes up a single byte in memory.}. It seemed unlikely that anyone testing MicroWac would create more variables than that. If, however, this is is the case, the compiler can easily be extended such that it keeps track of how much memory is spent, and makes sure to allocate enough pages to support the variable count.

\subsection{Outputting Binaries}
As the original MicroC compiler simply output the compiled programs as files containing the string representation of opcodes, the code could not be reused.

WebAssembly expects binaries to be Actual binaries. Fortunately, previous experience with the .NET \texttt{BinaryWriter}\footnote{https://msdn.microsoft.com/en-us/library/system.io.binarywriter} class reduced the effort required to implement writing binary data to a file.

\texttt{WasmMachine.fs} exposes the instruction opcodes, and a function to get the byte values of a instruction: \texttt{emitbytes}.

All of the binary-outputting code is contained in a single function inside \texttt{Wasmcomp.fs}: \texttt{compileWasmBinary}.

\subsubsection{LEB128: Variable size integer encoding}
Specified in the DWARF Debugging Information Format~\cite{DWARF}, the LEB128, or Little Endian Base 128, variable size integer encoding is used in WebAssembly to encode most integers in the binary format~\cite[\#numbers]{website:wasm-binary-encoding}. In layman's terms, the encoding can store arbitrary size integers in few bytes.

In the WebAssembly documentation, a LEB128 number is called either a \texttt{varuintN} for a unsigned LEB128 number, and \texttt{varintN} for a signed LEB128 number.

To encode integers with LEB128, the algorithm found in the paper~\cite{DWARF} must be implemented. To avoid spending time re-implementing LEB128, an open source (MIT-Licensed) version of the algorithm was found\footnote{https://github.com/yageek/LEB128/blob/d05713742dd56bc2d1eaed44956f20f6755fa4e9/Sources/LEB128.swift\#L79} - the algorithm, coded in Swift, has been translated to F\#. See the implementation of the function \texttt{i2leb} in~\ref{sec:appendix:code:WasmMachine.fs},~\nameref{sec:appendix:code:WasmMachine.fs}.

\begin{center}
    \begin{tabular}{| l | l | l | l |}
    \hline
    Hexadecimal & WebAssembly Binary & LEB128 & Signed LEB128 \\ \hline
    00    & 00000000 &     0 &    0 \\ \hline
    01    & 00000001 &     1 &    1 \\ \hline
    7F    & 01111111 &   127 &   -1 \\ \hline
    80 7F & 10000000 01111111 & 16256 & -128 \\ \hline
    2A    & 00101010 &    42 &   42 \\ \hline
    56    & 01010110 &    86 &  -42 \\ \hline
    \end{tabular}
\end{center}

The table above depicts how a set of numbers are encoded with LEB128 (unsigned and signed) and their binary representations.

The WebAssembly header is encoded as two 32-bit integers, so for this purpose a function \texttt{i2b} uses the \texttt{BitConverter} class found in the .NET library to convert an integer to bytes, the byte ordering is reversed as integers are little endian in WebAssembly.

\subsection{Dependency Graph}
\label{sec:technical:dependency-graph}
This section contains a dependency graph of the compiler, and a explanation of how the different modules fit together.

\begin{figure}[H]
	\includegraphics[width=0.65\textwidth]{DependencyGraph}
	\centering
	\caption{Dependency graph of the MicroWac compiler. \texttt{Program.fs} contains the entry point.}
\end{figure}

The dependency graph depicts how different parts of the compiler infrastructure are connected. The lexer, parser and Parse program depend on the FsLexYacc runtime, which exposes some tokenising and text parsing features, they also depend on the abstract syntax defined in \texttt{Absyn.fs}. The backend of the compiler also depends on the abstract syntax as it translates the tree generated by the frontend to binary WebAssembly code.

This design is almost identical to the one defined by Peter Sestoft. The only change is, that a \texttt{Program.fs} file exists, which exposes a \texttt{main} function that allows the compiler to be invoked via a command line terminal. It is a good design that splits the frontend and backend fairly well.

\newpage
\subsection{Extension to MicroC}
\label{sec:technical:extension}
MicroC has been extended with the \texttt{import} and \texttt{export} keywords. They can be used to define function prototypes (signatures) for dynamically linked function definitions, and to decide which functions to export to the instantiating environment. The keywords are added to the lexer, and the parser has been extended to accommodate the behaviour.

The formal grammar for these new keywords is:
\begin{minted}{fsharp}
ImportedFunsig ::= IMPORT Funsig               // example: import void fun(int x);

ExportedFundec ::= EXPORT Fundec               // example: export int fib(int n) { ... }

Funsig ::= VOID NAME LPAR Paramdecs RPAR SEMI  // example: void fun(int x);
        |  Type NAME LPAR Paramdecs RPAR SEMI  // example: int fun();
        
Fundec ::= VOID NAME LPAR Paramdecs RPAR Block // example: void log_n(int n) { ... }
        |  Type NAME LPAR Paramdecs RPAR Block // example: char int_to_char(int i) { ... }
\end{minted}

For the complete grammar, see~\ref{sec:appendix:code:CPar.fsy},~\nameref{sec:appendix:code:CPar.fsy}.

The abstract syntax is also extended for this feature to work: the notion of a function signature has been added, resembling function prototypes in C/C++, and a boolean has been added to the \texttt{Fundec} union type, declaring whether the function is exported or not. These changes can be found in~\ref{sec:appendix:code:Absyn.fs},~\nameref{sec:appendix:code:Absyn.fs}.

\subsection{F\# Signature Files}
It is considered wise to expose as little as possible from a module or library, therefore signature files are defined for most of the codebase. Signature files describe what to export from an implementation file, and act as a sort of high-level interface between modules.

Documentation added to the definitions declared in a signature file can be used by development environments, such as Visual Studio Code and Visual Studio, to provide contextual information when hovering the cursor over a function name.

\newpage
\section{Testing and Validation}
\label{sec:testing}
This section details how testing and validation has been conducted. Furthermore, known issues are examined.

\subsection{The PLC Tests}
\label{sec:testing:plc}
A set of 24 tests were supplied along with the original MicroC project\footnote{http://www.itu.dk/people/sestoft/plc/microc.zip}. In order to pass these tests, output of the WebAssembly binaries should equal output of the MicroC stack machine running the same program.

The tests encompasses number arithmetic, pointer arithmetic, arrays, looping- and logical constructs. For each of the \texttt{.c} examples in the \texttt{./micro-wac/test/plc/} directory, a comment has been inserted at the top of the test, to state whether the test passed or not.

Most tests were altered slightly, to allow the program to run at instantiation-time. A \texttt{start} function was added to tests, invoking \texttt{main}.

Test \#2 fails partially (on array access via pointer address addition). The failure of this test is explained in section~\ref{sec:testing:known-issues},~\nameref{sec:testing:known-issues}, issue \#2.

Test \#11 fails completely, due to a store operation being attempted on an empty stack. I unfortunately didn't have time to inspect and debug this test, but assume that the \texttt{varAccess} function messes something up somehow.

\subsection{Known Issues}
\label{sec:testing:known-issues}
What follows are the known issues in the compiler:
\begin{enumerate}
	\item All function return values MUST be consumed, otherwise the stack will have an incorrect count of elements on the stack at return, and will fail compilation in the browser. A way to solve this would be to ensure that, when the result of a called function is not used, its value is dropped from the stack using the WebAssembly \texttt{drop} instruction.

	Reproducible with:\\
	\mintinline{c}{int iReturn() { return 42; } void main() { iReturn(); }}
	
	Workaround until the issue is fixed:\\
	\mintinline{c}{int iReturn() { return 42; } void main() { int x; x = iReturn(); }}

	\item Array access using the dereferencing operator and addition is not working properly. In\\\nameref{sec:appendix:code:plc-ex2.c} line 27, the compiled program yields incorrect output. Not completely sure why this problem occurs, but I think it has something to do with the offset and relative addresses of variables (which are multiplied by their type width).

	\item Char type variables cannot be dereferenced or used as arrays. This bug exists because I failed to find a way to get the type information of a variable inside \texttt{AccDeref} and \texttt{AccIndex} constructs, so I generalized and used integers for everything. See \nameref{sec:appendix:code:Wasmcomp.fs} lines 228 and 235.

	\item The code that supports compilation of variable access (the \texttt{varAccess} function in \nameref{sec:appendix:code:Wasmcomp.fs}, lines 202 to 242) is a mess and is not very readable. Not really a bug, but probably the reason behind some.  Unfortunately, due to time constraints, I didn't get to clean it up.

	\item In the original MicroC compiler (written by Peter Sestoft), variables that are out of scope bleed into other scopes. A test, see \nameref{sec:appendix:code:test-scope.c}, revealed this problem. This issue does not exist in MicroWac, as MicroWac keeps track of the depth of variables, and declares them as being outside of a scope as soon as their enclosed scope ends.

	\item The control flow opcode \texttt{if} in WebAssembly can either return: a value of some type, or nothing. This must be declared for each if-block. If an if-block is set to return something, it MUST, otherwise instantiation in the browser will fail. As such, MicroWac attempts to figure out if an if-block should return something or not. It does this by checking the block that gets executed when the statement holds, and if that block contains a return statement, the if-block is set to return a value. Should the else-block not return anything, this will lead to an instantiation failure in the browser. This is an issue because MicroC does not have this limitation, but WebAssembly has. I didn't find a solution to this problem.
\end{enumerate}

\newpage
\section{Peripheral Programs and Tooling}
\label{sec:peripherals}
This section describes the use of peripheral programs and tooling that assist in: compiling the compiler, exposing the generated code from compiled MicroC programs, and handling WAST S-expression programs and WASM binaries.

Development of MicroWac was completed in Visual Studio 2017, and the plugin \texttt{F\# Outlining}\footnote{https://marketplace.visualstudio.com/items?itemName=lostmsu.FOutlining} was used to allow code folding on \texttt{//\#region} comments.

\subsection{Inspecting WASM Binaries}
\label{sec:peripherals:inspecting-wasm}
To inspect WebAssembly binaries (and ensure correctness) two hex viewers were used: HxD\footnote{https://mh-nexus.de/en/hxd/} on Windows, and https://hexed.it/ on OS X and Linux.

An expected output program was written in hand as a WAST file, then compiled to a WebAssembly binary using WABT. The corresponding MicroC program was then written, and compiled using MicroWac. The tools above could be used to inspect the binary hex representation of the WASM files.

\subsection{Lexer and Parser Generator}
\label{sec:peripherals:lexpargen}
Generating the parser and lexer is done by the tool: FsLexYacc. Unfortunately, FsLexYacc does not know if it needs to recompile, as changes are not tracked, thus it will always recompiles if it is added to the build process. Once the generator had delayed work enough times, a small solution was thought up, see appendix section~\ref{sec:appendix:code:pre-build-lexpar-comp},~\nameref{sec:appendix:code:pre-build-lexpar-comp}.

The pre-build scripts (a \texttt{.sh} version for *nix and a \texttt{.ps1} version for Windows) generates- and checks the hashes of the lexer and parser files. If the hash has changed from the cached version, it regenerates the lexer and parser. It was first written in PowerShell, then converted to Bash.

Under the hood the scripts use Gits' \texttt{hash-object} command, in order to stay OS agnostic.

\subsection{Testing \texttt{.wasm} output}
\label{sec:peripherals:testing-wasm}
Due to time constraints, the compiler is not directly exposed to a web environment\footnote{See section~\ref{sec:problem-definition:changes},~\nameref{sec:problem-definition:changes}.} This unfortunately increases the difficulty of executing binary output of the compiler. A flags has been introduced as a compiler argument to simplify this process: \texttt{-html}. If this flag is set while compiling, the compiler will generate a HTML file that loads the \texttt{.wasm} file.

A piece of JavaScript code in the HTML file uses the \texttt{fetch} API found in browsers. This API is not allowed via the \texttt{file://} protocol, thus requiring the file to be served with the \texttt{http://} protocol. It is, however, easy to run a webserver that exposes files on \texttt{http://localhost:<port>} with either Python (2 or 3) or Node.js.

To start a web server in the local directory with Node installed, first install \texttt{http-server} globally with: \verb$npm install -g http-server$. Once installed, the server can be started with the command \texttt{http-server} in the directory containing the HTML file(s).

Node may not be readily available, in which case maybe Python is. To start a web server with Python2, run the command \texttt{python -m SimpleHTTPServer}, and for Python3, run the command \texttt{python -m http.server}, no installation is required for either command.

\subsection{WABT - WebAssembly Binary Toolkit}
\label{sec:peripherals:wabt}
The Webassembly Binary Toolkit is used to create binaries (.wasm files) from S-expression files (.wast), and the reverse. During the project, the toolkit was used extensively to inspect binary output of the compiler, and to understand the S-expression syntax.

The tests located in \texttt{./micro-wac/test/expected-output/} were written by hand in the S-expression syntax, then compiled to binary with WABT: \mintinline{bash}{wast2wasm <name>.wast -o <name>.wasm}, and extra verbose output was generated with: \mintinline{bash}{wast2wasm <name>.wast -v > <name>.wasm.verbose}, this command essentially generates the binary in a human readable form with the addition of some informational comments.

To reverse the process, going from binary to S-expression, the command \texttt{wasm2wast <name>.wasm} was used to get the S-expression syntax version of the binary outputted to the console. This was very helpful when the compiled binaries were inspected.\\

\noindent WABT needs to be compiled using CMake and Make. Instructions can be found in the repository at\\https://github.com/WebAssembly/wabt.

\subsection{Run-test framework}
\label{sec:peripherals:run-test-framework}
In order to easily test hand-written S-expression WebAssembly modules, a tiny test framework was written. This framework is located in \texttt{./micro-wac/test/expected-output/}, in \texttt{run-test.html} and its connected files. To run the framework, start a web-server in the \texttt{expected-output} directory and navigate to \texttt{http://localhost:8080/run-test.html}.

\texttt{run-test-available.js} contains the WebAssembly modules available for testing, and can be generated with the \texttt{run-test-available.generate.\{ps1$|$sh\}} files.

The test framework loads the available WebAssembly modules and adds them to a list for the user to compile and run. The binary modules are inspected, such that any exported functions are also exposed and can be executed. Note, that when a function that takes arguments is called without, the arguments will be defaulted to a value of 0 (the \texttt{while.wast} sample, for instance).

When a program or function executed in the test framework outputs with a print function, the output can be found in the browsers console log. To access the log on Google Chrome, open the \texttt{Developer Tools}, then click \texttt{Console}.

\begin{figure}[H]
	\includegraphics[width=0.65\textwidth]{WasmTestFrameworkScreenshot}
	\centering
	\caption{Screenshot of the test framework in action.}
\end{figure}

\subsection{Prototyping in F\#}
\label{sec:peripherals:prototyping}
Prototyping different solutions with F\# is extremely easy. This fact was abused rigorously throughout the development process of the compiler. There was rarely a need to compile the compiler, and changes could be tested quickly with the following command:\\
\texttt{fsi -r \textasciitilde/fsharp/FsLexYacc.Runtime.dll Absyn.fs CPar.fs CLex.fs Parse.fs WasmMachine.fs WasmComp.fs}

This command opens up F\# interactive with the compiler loaded. To use the compiler within interactive type in: \texttt{open MicroWac;;} and start using the functions. By not including the \texttt{.fsi} files in the command, access is obtained to all functions, even those not exposed by the signature files - a neat trick.

\newpage
\section{Future Extensions}
\label{sec:extensions}
This section contains ideas on what the compiler could be extended with.

Possible future maintainers of this code are recommend to pour effort into cleaning up the code that handles variable storage in linear memory. When that part of the compiler is optimal, extending it should be a whole lot simpler.

\subsection{Compiler Optimisations}
\label{sec:extensions:optimisations}
Humans (should) write readable and maintainable code. A computer only cares about operations, and each operation costs some $x$ energy and time. The compiler can perform optimisations to reduce the amount of operations a program needs for some logic to be completed, this machine code reduction positively influences the compiled program, by reducing the energy consumed by a processor running it, and increasing the performance.

\textbf{Peephole optimisation} is a simple technique that consumes few resources and little time. The cause of this is that peephole optimisations only require knowledge of a few close operations in order to apply reductions.

\begin{figure}[H]
	\includegraphics[width=0.65\textwidth]{PeepholeOptimisationIllustrations}
	\centering
	\caption{The applied optimisation to the left stack is simple: adding two constants can be reduced to the result of the addition. The optimisation on the right hand side is more complex: suppose we have a global at position 5 that is immutable and contains the value 42. We can convert the get-call to the value of the variable, as it will never change, which leads to an operation sequence that resembles the one on the left hand side - which, then again, can be can be optimised even further.}
\end{figure}

In a forward compiler, optimising with peephole style optimisations can be added as a pass in the compiler backend, such that when the instruction code is generated, the compiler will run through it again, this time attempting to apply optimisations which attempts to reduce and remove code. For instance, if a function in a program adds two constants together and returns the result, an optimising compiler will reduce the expression to the result of the addition operation, and simply return that: \mintinline{c}{return 7+14; => return 21;}. The logic has not been tampered with, but the function is now 3 operations cheaper\footnote{One for each of the stack reads (reading 7 and 14) and then one for the resulting write operation.}. A more elaborate example can be found below.

\begin{figure}[H]
	\includegraphics[width=0.75\textwidth]{PeepholeOptimisation}
	\centering
	\caption{A simple function \texttt{optEx} multiplies the input argument with $0$ a few times and then returns the result of an addition. To the right of the function are the compiled and optimised versions of the code in WebAssembly stack machine code.}
\label{fig:peephole-optimisation}
\end{figure}
As can be seen in figure~\ref{fig:peephole-optimisation}, only the multiplication expressions are simplified. While peephole optimising, the compiler will not know if it can discard \texttt{a} entirely, as it could be referenced later, and the compiler does not know the value of \texttt{x}, nor what \texttt{a} contains anymore (we can see that it is equal to $0$, but our brains collect a lot of state regarding the program at hand, which allows us to deduce this), therefore, nothing can be optimised at the end of the function. Running a more complex and stateful optimisation technique could detect more redundant code, but such an optimisation is more resource- and time consuming.

Peephole optimisations alone fall short when more elaborate optimisations are needed. For instance, if you have many small functions you may want to inline them where used. If we reuse the example from above, with the add function, simply adding the result to the stack rather than calling the function each place is fewer operations, thus inlining would yield a benefit. During peephole optimisation, you won't have information regarding the environment, thus you won‚Äôt know what the function that is being called will do, and will not know if inlining that function is valid.

\subsection{Expose MicroWac to the Web}
As described in section~\ref{sec:problem-definition:method},~\nameref{sec:problem-definition:method}, the original intent was to create a web application that exposed an API to the compiler running on a server. This would give WebAssembly beginners the possibility figure out how code in a C-like language compiles to WebAssembly instantaneously.

Some legacy code from the inception of this project still remains in the \texttt{./web-backend/} directory. It contains some Node.js code (JavaScript) to start an Express.js server that can receive simple compile requests (\texttt{server.js}), and code to run processes and receive data from the \texttt{stdin/stderr} file descriptors (\texttt{playground.js}) which could be used to send errors back to the user.

This extension would be interesting to finish before WebAssembly becomes mainstream, as it's tools like these that are in high demand now, and not when toolchains have improved significantly in a year or two.

\newpage
\section{Conclusion}
\label{sec:conclusion}
There are a lot of gotchas' to be had when the WebAssembly specification is scrutinised. Although the design is simple, some features and design choices seem to have come out of nowhere and requires a lot of digging to find a rationale for, if it can be found at all. For instance, why did the working group decide not to have a base and stack pointer, or registers for that matter? Or, why did they decide to create 2 types of variables (global and local), but none that support referencing by address outside of the scope of a function (like how pointers to memory locations work in C)? It's impossible to know. Nevertheless, WebAssembly has been an extremely interesting technology to learn about, and I have no doubt that it will grow exponentially in popularity over the coming years as version 1 settles.

MicroWac generates properly working WebAssembly binaries from most MicroC code. It is tested against a test suite by Peter Sestoft and one written specifically for this project - although I believe that even more tests would've been very beneficial. Not all tests pass, which is not great, but some thoughts attempting to shed some light on this, are set forth in section~\ref{sec:testing:known-issues},~\nameref{sec:testing:known-issues}.

It is too bad that I ended up not having time to make the web interface prototype. I believe that it would've made it much easier to show how the WebAssembly binary format works. Fortunately, I also feel that the \texttt{-html} flag is not a bad replacement.\\

\noindent Gathering information about WebAssembly has been a starving experience. As it is a new format, there is still very little documentation and very few examples out in the wild. Had I wanted to create a MicroC to Java Bytecode compiler, I would've been able to swim in resources. This is not to say that the experience has been bad - being starved forced me to experiment with the format a lot more than I might've done otherwise, leading to a, I assume, even better understanding.\\

\noindent While I feel that the project is good and that I achieved the learning I set out to obtain, I am not completely satisfied with the code quality in all parts of the compiler. Some solutions feel like they were shoe-horned in, when they should've been well thought out and beautifully designed - I'm thinking about variable management. This is hopefully forgivable.

\newpage
\section{Open Source}
\noindent The creation of this project lead to contributions to a few open source projects:
\begin{itemize}
	\item https://github.com/ionide/ionide-vscode-fsharp/issues/427
	\item https://github.com/fsharp/FsAutoComplete/pull/163
	\item https://github.com/Microsoft/visualfsharpdocs/pull/286
\end{itemize}

\noindent MicroC is also released as open source under the GNU General Public License v3.0\footnote{See the license in \texttt{LICENSE.md}, or at https://www.gnu.org/licenses/gpl-3.0.en.html}, and can be forked on GitHub\footnote{https://github.com/AndreasHassing/microc-to-webassembly/}.

\section{References}
\label{sec:references}
\begingroup
\renewcommand{\section}[2]{}%
\bibliographystyle{plain}
\bibliography{Bibliography}{}
\endgroup

\newpage
\section{Appendix}
\label{sec:appendix}

\subsection{WebAssembly Examples}
\label{sec:appendix:wasm-examples}

\subsubsection{Print module compiled to WASM, explained}
\label{sec:appendix:wasm-examples:binary-print}
\begin{minted}[tabsize=2,breaklines]{text}
; Header
00 61 73 6D                  ; translates to '\0asm', WebAssembly magic number. Exists for quick file type detection.
01 00 00 00                  ; Version number (1)

; Section "Type" (1)
01                           ; Section code: 0x01 = Type
08                           ; Section size: 0x08 bytes (the following 8 bytes are contained within this section)
02                           ; Number of types in section: 2 types
; type 0
60                           ; Type code: 0x60 = function
01                           ; Number of params: 0x01
7F                           ; Type of 1st param: 0x7F = i32
00                           ; Number of results: 0x00
; type 1
60                           ; Type code: 0x60 = function
00                           ; Number of params: 0x00
00                           ; Number of results: 0x00

; Section "Import" (2) - spec: optional
02                           ; Section code: 0x02 = Import
12                           ; Section size: 0x12 bytes (decimal: 18)
01                           ; Number of imports: 0x1
; import header 0
07                           ; String length: 0x07 bytes
69 6D 70 6F 72 74 73         ; Import module name: ascii => "imports"
06                           ; String length: 0x06 bytes
70 72 69 6E 74 69            ; Import field name: ascii => "printi"
00                           ; Import kind: 0x00 (using external_kinds table: 0 = function) "https://github.com/WebAssembly/design/blob/master/BinaryEncoding.md#external_kind"
00                           ; Import signature index: 0x00 (referring to function signature at type 0)

; Section "Function" (3) - spec: required
03                           ; Section code: 0x03 = Function
02                           ; Section size: 0x02 bytes
01                           ; Number of functions: 0x01
01                           ; Function 0 signature index: 0x01 (refers to type 1)

; Section "Start" (8) - spec: optional
08                           ; Section code: 0x08 = Start
01                           ; Section size: 0x01 bytes
01                           ; Start function index (refers to function 1)

; Section "Code" (10) - spec: required
0A                           ; Section code: 0x0a = Code (decimal: 10)
11                           ; Section size: 0x11 bytes (decimal: 17)
01                           ; Number of functions: 0x01
0F                           ; Function body size: 0x0f (decimal: 15)
01                           ; Local variable declaration count: 0x01
01                           ; Local type count of immediate type identifier: 0x01
7F                           ; Type identifier for i32
41                           ; i32.const (the next opcode will be a literal)
05                           ; i32 literal: 0x05
41                           ; i32.const
03                           ; i32 literal: 0x03
6A                           ; i32.add (pop two values from stack, and add them, push result onto stack)
21                           ; set_local, take the next value pushed to the stack, and assign local at that index with stack pop value
00                           ; local variable index: 0x00
20                           ; get_local, take the next value pushed to the stack, and push local at that index onto stack
00                           ; local variable index: 0x00
10                           ; call function at index from next value pushed to stack
00                           ; function index: 0x00
0B                           ; end
\end{minted}

\newpage
\subsection{Code}
\label{sec:appendix:code}
Only code that is referred to directly in this report is included as part of this appendix. The full source code can be found in the \texttt{.zip}-file that contained this report. If you only have the report in PDF format, see https://github.com/AndreasHassing/microc-to-webassembly.

\subsubsection{micro-wac/pre-build-lexpar-comp.\{sh$|$ps1\}}
\label{sec:appendix:code:pre-build-lexpar-comp}
\textbf{PowerShell Version}
\inputminted[breaklines,tabsize=2,linenos]{powershell}{../micro-wac/pre-build-lexpar-comp.ps1}

\newpage
\noindent\textbf{Bash Version}
\inputminted[breaklines,tabsize=2,linenos]{bash}{../micro-wac/pre-build-lexpar-comp.sh}

\newpage
\subsubsection{micro-wac/WasmBootstrapTemplate.html}
\label{sec:appendix:code:bootstrap-template}
\inputminted[breaklines,tabsize=2,linenos]{html}{../micro-wac/WasmBootstrapTemplate.html}

\newpage
\subsubsection{micro-wac/Absyn.fs}
\label{sec:appendix:code:Absyn.fs}
\inputminted[breaklines,tabsize=2,linenos]{fsharp}{../micro-wac/Absyn.fs}

\newpage
\subsubsection{micro-wac/CPar.fsy}
\label{sec:appendix:code:CPar.fsy}
\inputminted[breaklines,tabsize=2,linenos]{fsharp}{../micro-wac/CPar.fsy}

\newpage
\subsubsection{micro-wac/WasmMachine.fs}
\label{sec:appendix:code:WasmMachine.fs}
\inputminted[breaklines,tabsize=2,linenos]{fsharp}{../micro-wac/WasmMachine.fs}

\newpage
\subsubsection{micro-wac/Wasmcomp.fs}
\label{sec:appendix:code:Wasmcomp.fs}
\inputminted[breaklines,tabsize=2,linenos]{fsharp}{../micro-wac/Wasmcomp.fs}

\newpage
\subsubsection{micro-wac/test/scope.c}
\label{sec:appendix:code:test-scope.c}
\inputminted[breaklines,tabsize=2,linenos]{c}{../micro-wac/test/scope.c}

\newpage
\subsubsection{micro-wac/test/plc/ex2.c}
\label{sec:appendix:code:plc-ex2.c}
\inputminted[breaklines,tabsize=2,linenos]{c}{../micro-wac/test/plc/ex2.c}

\end{document}
